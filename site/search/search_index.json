{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction A place for our Sudofy 's Developers to share their knowledge. We Conduct Session every 2 to 3 weeks on latest Technology trends. Outsiders are currently not allowed but can grant access prior to an STS Timeline Author Technology Date Docs Slide Amin Ahmed Khan STS Intro 20-12-2017 Docs Slide Alqama Bin Sadiq Async Await 04-08-2018 Docs Slide Faraz Sarwar Service Workers 18-08-2018 Docs Slide Notes Conduct a session maybe? If you want to conduct any session. Just Shout out in the #STS channel on sudofy's slack workspace","title":"Home"},{"location":"#introduction","text":"A place for our Sudofy 's Developers to share their knowledge. We Conduct Session every 2 to 3 weeks on latest Technology trends. Outsiders are currently not allowed but can grant access prior to an STS","title":"Introduction"},{"location":"#timeline","text":"Author Technology Date Docs Slide Amin Ahmed Khan STS Intro 20-12-2017 Docs Slide Alqama Bin Sadiq Async Await 04-08-2018 Docs Slide Faraz Sarwar Service Workers 18-08-2018 Docs Slide","title":"Timeline"},{"location":"#notes","text":"Conduct a session maybe? If you want to conduct any session. Just Shout out in the #STS channel on sudofy's slack workspace","title":"Notes"},{"location":"intro-service-worker/","text":"Introduction to Service Worker Table of Content Topics Real world problems Introduction to Service Worker Benefits of Offline First Registering a Service Worker Lifecycle of Service Worker Real world example Introduction to Service Worker Service worker is a JavaScript file that, run seperately in its own thread. Intercepts network request and store or retrive data from cache and provide push message to web client even when offline. It doesn't have DOM support and only run on HTTPS. Service worker doesn't have access to DOM, so what can we do with JavaScript? Lets discus this. Service worker is like a middle man (or middleware) between the webpage and the internet, it handle the network request. When a webpage request the server for HTML, CSS files or any API request it pass through the service worker, it is up to us how we code the service worker to deal with these request like we can send that request to server or we can look for the request in cache if exist then show from cache. It is up to us what approach is better for us to provide a good user experience. Benefits of Offline First Before service worker, AppCache was used by the developer to cache data. In AppCache first network request was made by the site to server and then cache the request when it is completed and whenever the request was failed it was retrive from AppCache . The drawback of this is, user kept waiting till the network request made or failed which is a bad exprience for the user, so that why AppCache has been depriciated and Service Worker was introduced on 08 May, 2014 . Below is the image show the working of AppCache : Referenced from Udacity Course As Service Worker was introduced, a new approach come into play to develop a web app Offline First i.e a request to a server is pass through service worker, it will look for data in cache and show the content of the web page that already cache meanwhile gets the respone from the server and show the rest of the content by this approach user wouldn't wait for page to completely load and shouldn't see the white screen all the time. Below the image describe the flow of service worker. Referenced from Udacity Course Registering a Service Worker To register a service worker, first we need to check if the service worker is supported by the broswer or not, to do so we need to check for service worker object in navigator . Navigator object contains the information about the user agent and browser. if (navigator.serviceWorker) { navigator.serviceWorker.register('/sw.js').then(function(reg) { console.log('Yay!!'); }, function(err) { console.log('Boo!!'); }); } where sw.js is the service worker file located at the root level of project (in my case) it could be of any name and located anywhere inside the project but it is good to have it on root level. Lifecycle of Service Worker Service worker handle requests to the server. It has a few steps, and to show that I\u2019ll show your a nice picture from MDN : Parsed Event When we first attempt to register a Service Worker, the user agent parses the script and obtains the entry point. If parsing is successful (and some other requirements, e.g. HTTPS, are met), we will have access to the Service Worker registration object. This contains information about the state of the Service Worker as well as it\u2019s scope. if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js') .then(function(registration) { console.log( Service Worker Registered , registration); }) .catch(function(err) { console.log( Service Worker Failed to Register , err); }) } Install Event Once the Service Worker script has been parsed, the user agent attempts to install it and it moves to the installing state. In the Service Worker registration object, we can check for this state in the installing child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.installing) { // Service Worker is Installing } }); During the installing state, the install event in the Service Worker script is carried out. The \u201cinstall\u201d event is the first event a service worker gets, and it only happens once. A promise passed to event.waitUntil() signals the duration and success or failure of your install. A service worker won't receive events like fetch and push until it successfully finishes installing and becomes \"active\". By default, a page's fetches won't go through a service worker unless the page request itself went through a service worker. So you'll need to refresh the page to see the effects of the service worker. An example image shown by Jake Archibald in his blog : To listen the install event of a service worker, we need to add the following code in our sw.js file: self.addEventListener('install', function(event) { event.waitUntil( // Open cache storage and do something ); }); Installed / Waiting If the installation is successful, the Service Worker moves to the installed (also called waiting) state. In this state it is a valid, but not yet active, worker. It is not yet in control of the document, but rather is waiting to take control from the current worker. In the Service Worker registration object, we can check for this state in the waiting child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.waiting) { // Service Worker is Waiting } }); This can be a good time to notify the app user that they can update to a new version, or automatically update for them. Activate Event After the installation of service worker, if there any existing service worker controlling the client, then this worker goes to a waiting state. The activate event fires once the old service worker is gone, and your new service worker is able to control clients. This is the ideal time to do stuff that you couldn't do while the old worker was still in use, such as migrating databases and clearing caches. The waiting phase means you're only running one version of your site at once, but if you don't need that feature, you can make your new service worker activate sooner by calling \u201cself.skipWaiting()\u201d. An example image shown by Jake Archibald in his blog : To listen the activate event of a service worker, we need to add the following code in our sw.js file: self.addEventListener('activate', function(event) { event.waitUntil( // Delete cache ); }); Activated If activation is successful, the Service Worker moves to the active state. In this state, it is an active worker in full control of the document. In the Service Worker registration object, we can check for this state in the active child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.active) { // Service Worker is Active } }); When a Service Worker is active, it can now handle the functional events - fetch, and message. self.addEventListener('fetch', function(event) { // Do stuff with fetch events }); self.addEventListener('message', function(event) { // Do stuff with postMessages received from document }); Redundant A Service Worker can become redundant for one of the following reasons - If the installing event failed If the activating event failed If a new Service Worker replaces it as the active service worker CacheStorage The Cache API is a system for storing and retrieving network requests and corresponding responses. The Cache API was created to enable Service Workers to cache network requests so that they can provide appropriate responses even while offline. However, the API can also be used as a general storage mechanism. What can be stored? The caches only store pairs of \u201cRequest\u201d and \u201cResponse\u201d objects, representing HTTP requests and responses. However, the requests and responses can contain any kind of data that can be transferred over HTTP. The API is exposed via the global \u201ccaches\u201d property, so you can test for the presence of the API with a simple feature detection: if('caches' in window) { // HAS SUPPORT!! } The API can be accessed from a window, iframe, worker, or service worker Methods of CacheStorage Methods Description open(cacheName) Returns a Promise that resolves to the Cache object matching the cacheName (a new cache is created if it doesn\u2019t already exist). match() Checks if a given Request is a key in any of the Cache objects that the CacheStorage tracks, and returns a Promise that resolves to that match. has(cacheName) Returns a Promise that resolves to \u201cTRUE\u201d if a Cache object matching the cacheName exits. keys() Returns a Promise that will resolve an array containing strings corresponding to all of the named Cache objects tracked by the CacheStorage. Use this method to iterate over a list of all the Cache object. delete(cacheName) Finds the Cache object matching the cacheName if found, delete the Cache object and returns a Promise that resolves to \u201cTRUE\u201d. If no Cache object is found, it returns \u201cFALSE\u201d. Creating or opening a cache // \u201ccaches\u201d is a global read-only variable, which is the instance of CacheStorage. caches.open('my-cache').then((cache) = { // do something with cache\u2026 }); Note: Give your cache names a unique prefix so that it don\u2019t override the other domain cache For ex: \u2018mysite-static-v1\u2019 Adding to cache caches.open('test-cache').then(function(cache) { cache.addAll(['/', '/images/logo.png']) .then(function() { // Cached! }); }); caches.open('test-cache').then(function(cache) { cache.add('/images/logo.png') .then(function() { // Cached! }); }); The addAll method accepts an array of URLs that should be cached, to add single URL, use the add method put() put() is similar to add() but in, put() we can add response object. fetch('/page/1').then(function(response) { return caches.open('test-cache') .then(function(cache) { return cache.put('/page/1', response); }); }); Retrieving Cache caches.open('test-cache').then(function(cache) { cache.keys().then(function(cachedRequests) { console.log(cachedRequests); // [Request, Request] }); }); caches.open('test-cache').then(function(cache) { cache.match('/page/1') .then(function(matchedResponse) { console.log(matchedResponse); }); }); /* Request { bodyUsed: false credentials: omit headers: Headers integrity: method: GET mode: no-cors redirect: follow referrer: url: https://staging.pitchworthy.co/images/logo.png }*/ /*Response { body: (...), bodyUsed: false, headers: Headers, ok: true, status: 200, statusText: OK , type: basic , url: https://staging.pitchworthy.co/users/me } */ caches.keys To get the names of existing caches, use \u201ccaches.keys\u201d caches.keys().then(function(cacheKeys) { console.log(cacheKeys); // ex: [ test-cache ] }); Deleting a Cache caches.delete('test-cache').then(function() { console.log('Cache successfully deleted!'); }); Delete an old cache and add new one You often need to delete an old cache and add new one. // Assuming `CACHE_NAME` is the newest name. Time to clean up the old! var CACHE_NAME = 'version-8'; caches.keys().then(function(cacheNames) { return Promise.all( cacheNames.map(function(cacheName) { if(cacheName != CACHE_NAME) { return caches.delete(cacheName); } }) ); });","title":"2. Intro to Service Workers (1 of 2)"},{"location":"intro-service-worker/#introduction-to-service-worker","text":"","title":"Introduction to Service Worker"},{"location":"intro-service-worker/#table-of-content","text":"Topics Real world problems Introduction to Service Worker Benefits of Offline First Registering a Service Worker Lifecycle of Service Worker Real world example","title":"Table of Content"},{"location":"intro-service-worker/#introduction-to-service-worker_1","text":"Service worker is a JavaScript file that, run seperately in its own thread. Intercepts network request and store or retrive data from cache and provide push message to web client even when offline. It doesn't have DOM support and only run on HTTPS. Service worker doesn't have access to DOM, so what can we do with JavaScript? Lets discus this. Service worker is like a middle man (or middleware) between the webpage and the internet, it handle the network request. When a webpage request the server for HTML, CSS files or any API request it pass through the service worker, it is up to us how we code the service worker to deal with these request like we can send that request to server or we can look for the request in cache if exist then show from cache. It is up to us what approach is better for us to provide a good user experience.","title":"Introduction to Service Worker"},{"location":"intro-service-worker/#benefits-of-offline-first","text":"Before service worker, AppCache was used by the developer to cache data. In AppCache first network request was made by the site to server and then cache the request when it is completed and whenever the request was failed it was retrive from AppCache . The drawback of this is, user kept waiting till the network request made or failed which is a bad exprience for the user, so that why AppCache has been depriciated and Service Worker was introduced on 08 May, 2014 . Below is the image show the working of AppCache : Referenced from Udacity Course As Service Worker was introduced, a new approach come into play to develop a web app Offline First i.e a request to a server is pass through service worker, it will look for data in cache and show the content of the web page that already cache meanwhile gets the respone from the server and show the rest of the content by this approach user wouldn't wait for page to completely load and shouldn't see the white screen all the time. Below the image describe the flow of service worker. Referenced from Udacity Course","title":"Benefits of Offline First"},{"location":"intro-service-worker/#registering-a-service-worker","text":"To register a service worker, first we need to check if the service worker is supported by the broswer or not, to do so we need to check for service worker object in navigator . Navigator object contains the information about the user agent and browser. if (navigator.serviceWorker) { navigator.serviceWorker.register('/sw.js').then(function(reg) { console.log('Yay!!'); }, function(err) { console.log('Boo!!'); }); } where sw.js is the service worker file located at the root level of project (in my case) it could be of any name and located anywhere inside the project but it is good to have it on root level.","title":"Registering a Service Worker"},{"location":"intro-service-worker/#lifecycle-of-service-worker","text":"Service worker handle requests to the server. It has a few steps, and to show that I\u2019ll show your a nice picture from MDN :","title":"Lifecycle of Service Worker"},{"location":"intro-service-worker/#parsed-event","text":"When we first attempt to register a Service Worker, the user agent parses the script and obtains the entry point. If parsing is successful (and some other requirements, e.g. HTTPS, are met), we will have access to the Service Worker registration object. This contains information about the state of the Service Worker as well as it\u2019s scope. if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js') .then(function(registration) { console.log( Service Worker Registered , registration); }) .catch(function(err) { console.log( Service Worker Failed to Register , err); }) }","title":"Parsed Event"},{"location":"intro-service-worker/#install-event","text":"Once the Service Worker script has been parsed, the user agent attempts to install it and it moves to the installing state. In the Service Worker registration object, we can check for this state in the installing child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.installing) { // Service Worker is Installing } }); During the installing state, the install event in the Service Worker script is carried out. The \u201cinstall\u201d event is the first event a service worker gets, and it only happens once. A promise passed to event.waitUntil() signals the duration and success or failure of your install. A service worker won't receive events like fetch and push until it successfully finishes installing and becomes \"active\". By default, a page's fetches won't go through a service worker unless the page request itself went through a service worker. So you'll need to refresh the page to see the effects of the service worker. An example image shown by Jake Archibald in his blog : To listen the install event of a service worker, we need to add the following code in our sw.js file: self.addEventListener('install', function(event) { event.waitUntil( // Open cache storage and do something ); });","title":"Install Event"},{"location":"intro-service-worker/#installed-waiting","text":"If the installation is successful, the Service Worker moves to the installed (also called waiting) state. In this state it is a valid, but not yet active, worker. It is not yet in control of the document, but rather is waiting to take control from the current worker. In the Service Worker registration object, we can check for this state in the waiting child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.waiting) { // Service Worker is Waiting } }); This can be a good time to notify the app user that they can update to a new version, or automatically update for them.","title":"Installed / Waiting"},{"location":"intro-service-worker/#activate-event","text":"After the installation of service worker, if there any existing service worker controlling the client, then this worker goes to a waiting state. The activate event fires once the old service worker is gone, and your new service worker is able to control clients. This is the ideal time to do stuff that you couldn't do while the old worker was still in use, such as migrating databases and clearing caches. The waiting phase means you're only running one version of your site at once, but if you don't need that feature, you can make your new service worker activate sooner by calling \u201cself.skipWaiting()\u201d. An example image shown by Jake Archibald in his blog : To listen the activate event of a service worker, we need to add the following code in our sw.js file: self.addEventListener('activate', function(event) { event.waitUntil( // Delete cache ); });","title":"Activate Event"},{"location":"intro-service-worker/#activated","text":"If activation is successful, the Service Worker moves to the active state. In this state, it is an active worker in full control of the document. In the Service Worker registration object, we can check for this state in the active child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.active) { // Service Worker is Active } }); When a Service Worker is active, it can now handle the functional events - fetch, and message. self.addEventListener('fetch', function(event) { // Do stuff with fetch events }); self.addEventListener('message', function(event) { // Do stuff with postMessages received from document });","title":"Activated"},{"location":"intro-service-worker/#redundant","text":"A Service Worker can become redundant for one of the following reasons - If the installing event failed If the activating event failed If a new Service Worker replaces it as the active service worker","title":"Redundant"},{"location":"intro-service-worker/#cachestorage","text":"The Cache API is a system for storing and retrieving network requests and corresponding responses. The Cache API was created to enable Service Workers to cache network requests so that they can provide appropriate responses even while offline. However, the API can also be used as a general storage mechanism.","title":"CacheStorage"},{"location":"intro-service-worker/#what-can-be-stored","text":"The caches only store pairs of \u201cRequest\u201d and \u201cResponse\u201d objects, representing HTTP requests and responses. However, the requests and responses can contain any kind of data that can be transferred over HTTP. The API is exposed via the global \u201ccaches\u201d property, so you can test for the presence of the API with a simple feature detection: if('caches' in window) { // HAS SUPPORT!! } The API can be accessed from a window, iframe, worker, or service worker","title":"What can be stored?"},{"location":"intro-service-worker/#methods-of-cachestorage","text":"Methods Description open(cacheName) Returns a Promise that resolves to the Cache object matching the cacheName (a new cache is created if it doesn\u2019t already exist). match() Checks if a given Request is a key in any of the Cache objects that the CacheStorage tracks, and returns a Promise that resolves to that match. has(cacheName) Returns a Promise that resolves to \u201cTRUE\u201d if a Cache object matching the cacheName exits. keys() Returns a Promise that will resolve an array containing strings corresponding to all of the named Cache objects tracked by the CacheStorage. Use this method to iterate over a list of all the Cache object. delete(cacheName) Finds the Cache object matching the cacheName if found, delete the Cache object and returns a Promise that resolves to \u201cTRUE\u201d. If no Cache object is found, it returns \u201cFALSE\u201d.","title":"Methods of CacheStorage"},{"location":"intro-service-worker/#creating-or-opening-a-cache","text":"// \u201ccaches\u201d is a global read-only variable, which is the instance of CacheStorage. caches.open('my-cache').then((cache) = { // do something with cache\u2026 }); Note: Give your cache names a unique prefix so that it don\u2019t override the other domain cache For ex: \u2018mysite-static-v1\u2019","title":"Creating or opening a cache"},{"location":"intro-service-worker/#adding-to-cache","text":"caches.open('test-cache').then(function(cache) { cache.addAll(['/', '/images/logo.png']) .then(function() { // Cached! }); }); caches.open('test-cache').then(function(cache) { cache.add('/images/logo.png') .then(function() { // Cached! }); }); The addAll method accepts an array of URLs that should be cached, to add single URL, use the add method","title":"Adding to cache"},{"location":"intro-service-worker/#put","text":"put() is similar to add() but in, put() we can add response object. fetch('/page/1').then(function(response) { return caches.open('test-cache') .then(function(cache) { return cache.put('/page/1', response); }); });","title":"put()"},{"location":"intro-service-worker/#retrieving-cache","text":"caches.open('test-cache').then(function(cache) { cache.keys().then(function(cachedRequests) { console.log(cachedRequests); // [Request, Request] }); }); caches.open('test-cache').then(function(cache) { cache.match('/page/1') .then(function(matchedResponse) { console.log(matchedResponse); }); }); /* Request { bodyUsed: false credentials: omit headers: Headers integrity: method: GET mode: no-cors redirect: follow referrer: url: https://staging.pitchworthy.co/images/logo.png }*/ /*Response { body: (...), bodyUsed: false, headers: Headers, ok: true, status: 200, statusText: OK , type: basic , url: https://staging.pitchworthy.co/users/me } */","title":"Retrieving Cache"},{"location":"intro-service-worker/#cacheskeys","text":"To get the names of existing caches, use \u201ccaches.keys\u201d caches.keys().then(function(cacheKeys) { console.log(cacheKeys); // ex: [ test-cache ] });","title":"caches.keys"},{"location":"intro-service-worker/#deleting-a-cache","text":"caches.delete('test-cache').then(function() { console.log('Cache successfully deleted!'); });","title":"Deleting a Cache"},{"location":"intro-service-worker/#delete-an-old-cache-and-add-new-one","text":"You often need to delete an old cache and add new one. // Assuming `CACHE_NAME` is the newest name. Time to clean up the old! var CACHE_NAME = 'version-8'; caches.keys().then(function(cacheNames) { return Promise.all( cacheNames.map(function(cacheName) { if(cacheName != CACHE_NAME) { return caches.delete(cacheName); } }) ); });","title":"Delete an old cache and add new one"},{"location":"js-async-await/","text":"Event loops and the asynchronous programming in Javascript This STS is based on the importance of Asynchronous programming in Javascript and how Javascript actually works, how it executes callbacks and handles asynchronous code. It will also cover how to use Callbacks, Promises and Async Await effectively in your code. This session will also cover little bit about the concept of Generators in javaScript. Links Slide Introduction The session is divided into three sections. The first section will cover how event loops and call stack work in JavaScript. The Second section will cover how to write non-blocking and asynchronous code in JavaScript and how to use Promises, call backs and Async-Await effectively and then the last section will cover the concept of Generators in Javascript. WHY Event Loops and Call Stack ? Call stacks and event loops are very important and it helps you understand how Javascript actually runs on browser and node. It also helps you in understanding how callbacks are actually handled in JavaScript. WHY Aysnc Await ? ES 2017 introduced Asynchronous functions. Async functions are essentially a cleaner way to work with asynchronous code in JavaScript. Here are some important points to remember: Async/await is a new way to write asynchronous code. Previous options for asynchronous code are callbacks and promises. Async/await is actually built on top of promises. It cannot be used with plain callbacks or node callbacks. Async/await is, like promises, non blocking. Async/await makes asynchronous code look and behave a little more like synchronous code. This is where all its power lies. WHY Generators ? Generators are functions that you can use to control the iterator. They can be suspended and later resumed at any time. So if you wanna do something in your function which involves stopping it and perform other operations and then resume that function again, you should learn how to use Generators. STS Date 04 - AUG - 2017 STS Duration 30-45 Mins STS Slides Google Docs Slides STS Snacks are on the house Donuts !","title":"1. JS Async Await"},{"location":"js-async-await/#event-loops-and-the-asynchronous-programming-in-javascript","text":"This STS is based on the importance of Asynchronous programming in Javascript and how Javascript actually works, how it executes callbacks and handles asynchronous code. It will also cover how to use Callbacks, Promises and Async Await effectively in your code. This session will also cover little bit about the concept of Generators in javaScript.","title":"Event loops and the asynchronous programming in Javascript"},{"location":"js-async-await/#links","text":"Slide","title":"Links"},{"location":"js-async-await/#introduction","text":"The session is divided into three sections. The first section will cover how event loops and call stack work in JavaScript. The Second section will cover how to write non-blocking and asynchronous code in JavaScript and how to use Promises, call backs and Async-Await effectively and then the last section will cover the concept of Generators in Javascript.","title":"Introduction"},{"location":"js-async-await/#why-event-loops-and-call-stack","text":"Call stacks and event loops are very important and it helps you understand how Javascript actually runs on browser and node. It also helps you in understanding how callbacks are actually handled in JavaScript.","title":"WHY Event Loops and Call Stack ?"},{"location":"js-async-await/#why-aysnc-await","text":"ES 2017 introduced Asynchronous functions. Async functions are essentially a cleaner way to work with asynchronous code in JavaScript. Here are some important points to remember: Async/await is a new way to write asynchronous code. Previous options for asynchronous code are callbacks and promises. Async/await is actually built on top of promises. It cannot be used with plain callbacks or node callbacks. Async/await is, like promises, non blocking. Async/await makes asynchronous code look and behave a little more like synchronous code. This is where all its power lies.","title":"WHY Aysnc Await ?"},{"location":"js-async-await/#why-generators","text":"Generators are functions that you can use to control the iterator. They can be suspended and later resumed at any time. So if you wanna do something in your function which involves stopping it and perform other operations and then resume that function again, you should learn how to use Generators.","title":"WHY Generators ?"},{"location":"js-async-await/#sts-date","text":"04 - AUG - 2017","title":"STS Date"},{"location":"js-async-await/#sts-duration","text":"30-45 Mins","title":"STS Duration"},{"location":"js-async-await/#sts-slides","text":"Google Docs Slides","title":"STS Slides"},{"location":"js-async-await/#sts-snacks-are-on-the-house","text":"Donuts !","title":"STS Snacks are on the house"},{"location":"sts-intro/","text":"STS Intro This STS is based on, The importance of and general announcement of the Sudofy Tech Session! Links Slide Introduction Sudofy Tech Session is an awesome way of sharing your experience at sudofy! These session helps create technology awareness between the developers of sudofy. These session will be conducted every alternate week on Monday. A session can only be 30 to 45 mins long. WHY STS ? The greatest enemy of learning is knowing. John Maxwell STS is going to help us involve in healthy discussion on development and daily process. Each Session will comply to these common goals How to value customer satisfaction How to increase efficiency at work Deliver Quality code Ways to improve UI/UX Future Technology that can beneficial Increase governance and security of apps HOW STS ? The next question is how are we going to conduct these session at sudofy. As mentioned above we are going to do this every alternate week on Monday. Further lets discuss the flow of the session STS Days Every Alternate Monday STS Duration 30-45 Mins STS Timeline The Timeline for this session will updated frequently and all future and past STS will be listed over here STS contribution Before giving any STS you have to submit a PR with your docs and slides. The PR must be submitted 3 days before the STS STS Docs Each STS will include its own Doc page written in MkdDos STS Slides Each STS Will include its own slides created on Google Docs Slides STS Snacks are on the house Each STS session will end with refreshments and snacks WHAT STS ? What will be included in a STS? STS Will be a short byte sized session on any Technology that the developer want to share with his follow developers. STS Topics New Technology QA/Testing Deployment Techniques Framework upgrade Dev Tools FAQS Where to host my Slides Kindly use Google Docs Slides How to write the Docs Kindly use MkdDos When To Submit a PR A PR for STS Should be submitted 3 days before the STS In case of not conducting (as a speaker) the STS For any case if you are not able to conduct the STS kindly inform 4 days before the STS Do I have to attend a STS Every Developer at sudofy must attend every STS","title":"0. Introduction"},{"location":"sts-intro/#sts-intro","text":"This STS is based on, The importance of and general announcement of the Sudofy Tech Session!","title":"STS Intro"},{"location":"sts-intro/#links","text":"Slide","title":"Links"},{"location":"sts-intro/#introduction","text":"Sudofy Tech Session is an awesome way of sharing your experience at sudofy! These session helps create technology awareness between the developers of sudofy. These session will be conducted every alternate week on Monday. A session can only be 30 to 45 mins long.","title":"Introduction"},{"location":"sts-intro/#why-sts","text":"The greatest enemy of learning is knowing. John Maxwell STS is going to help us involve in healthy discussion on development and daily process. Each Session will comply to these common goals How to value customer satisfaction How to increase efficiency at work Deliver Quality code Ways to improve UI/UX Future Technology that can beneficial Increase governance and security of apps","title":"WHY STS ?"},{"location":"sts-intro/#how-sts","text":"The next question is how are we going to conduct these session at sudofy. As mentioned above we are going to do this every alternate week on Monday. Further lets discuss the flow of the session","title":"HOW STS ?"},{"location":"sts-intro/#sts-days","text":"Every Alternate Monday","title":"STS Days"},{"location":"sts-intro/#sts-duration","text":"30-45 Mins","title":"STS Duration"},{"location":"sts-intro/#sts-timeline","text":"The Timeline for this session will updated frequently and all future and past STS will be listed over here","title":"STS Timeline"},{"location":"sts-intro/#sts-contribution","text":"Before giving any STS you have to submit a PR with your docs and slides. The PR must be submitted 3 days before the STS","title":"STS contribution"},{"location":"sts-intro/#sts-docs","text":"Each STS will include its own Doc page written in MkdDos","title":"STS Docs"},{"location":"sts-intro/#sts-slides","text":"Each STS Will include its own slides created on Google Docs Slides","title":"STS Slides"},{"location":"sts-intro/#sts-snacks-are-on-the-house","text":"Each STS session will end with refreshments and snacks","title":"STS Snacks are on the house"},{"location":"sts-intro/#what-sts","text":"What will be included in a STS? STS Will be a short byte sized session on any Technology that the developer want to share with his follow developers.","title":"WHAT STS ?"},{"location":"sts-intro/#sts-topics","text":"New Technology QA/Testing Deployment Techniques Framework upgrade Dev Tools","title":"STS Topics"},{"location":"sts-intro/#faqs","text":"Where to host my Slides Kindly use Google Docs Slides How to write the Docs Kindly use MkdDos When To Submit a PR A PR for STS Should be submitted 3 days before the STS In case of not conducting (as a speaker) the STS For any case if you are not able to conduct the STS kindly inform 4 days before the STS Do I have to attend a STS Every Developer at sudofy must attend every STS","title":"FAQS"}]}