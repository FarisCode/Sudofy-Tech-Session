{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction A place for our Sudofy 's Developers to share their knowledge. We Conduct Session every 2 to 3 weeks on latest Technology trends. Outsiders are currently not allowed but can grant access prior to an STS Timeline Author Technology Date Docs Slide Amin Ahmed Khan STS Intro 20-12-2017 Docs Slide Alqama Bin Sadiq Async Await 04-08-2018 Docs Slide Faraz Sarwar Service Workers 18-08-2018 Docs Slide Faraz Sarwar Service Workers 15-09-2018 Docs Slide ___ Notes Conduct a session maybe? If you want to conduct any session. Just Shout out in the #STS channel on sudofy's slack workspace","title":"Home"},{"location":"#introduction","text":"A place for our Sudofy 's Developers to share their knowledge. We Conduct Session every 2 to 3 weeks on latest Technology trends. Outsiders are currently not allowed but can grant access prior to an STS","title":"Introduction"},{"location":"#timeline","text":"Author Technology Date Docs Slide Amin Ahmed Khan STS Intro 20-12-2017 Docs Slide Alqama Bin Sadiq Async Await 04-08-2018 Docs Slide Faraz Sarwar Service Workers 18-08-2018 Docs Slide Faraz Sarwar Service Workers 15-09-2018 Docs Slide ___","title":"Timeline"},{"location":"#notes","text":"Conduct a session maybe? If you want to conduct any session. Just Shout out in the #STS channel on sudofy's slack workspace","title":"Notes"},{"location":"intro-service-worker-2/","text":"Introduction to Service Worker Table of Content Topics Overview App Introduction Installing/Running the App Registering our first Service Worker Exploring the Dev Tools Hijacking Request Caching and Serving Assets Unobtrosive App Updates Trigger latest version Update Data using the IndexedDB Overview Service worker is a JavaScript file that, run seperately in its own thread. Intercepts network request and store or retrive data from cache and provide push message to web client even when offline. It doesn't have DOM support and only run on HTTPS. Service worker doesn't have access to DOM, so what can we do with JavaScript? Lets discus this. Service worker is like a middle man (or middleware) between the webpage and the internet, it handle the network request. When a webpage request the server for HTML, CSS files or any API request it pass through the service worker, it is up to us how we code the service worker to deal with these request like we can send that request to server or we can look for the request in cache if exist then show from cache. It is up to us what approach is better for us to provide a good user experience. App Introduction We have an app called Wittr , it is a real time social networking web app where user share their posts and give comments/feedback on them. This site is fully developed but not a total breakdown on low connectivity and offline mode. So we going to implement the service worker to tackle the blank screen on low connectivity and offline mode. Installing/Running the App To install the app on you local machine, you first need to install Git if you have it that's great. If you dont know about Git that's not an issue we are just using the basic of Git . Those who dont know Git, it is a version controlling system. To download or clone the project to your local machine, run command on your terminal or command-line. git clone https://github.com/farazsarwar113/wittr After cloning the project run command npm install to install all the dependencies required by the project. To run the app run gulp serve . It will run the app on http://localhost:8888 and server on http://localhost:8889 . Registering our first Service Worker We need to work on only two files throughout the app public/js/sw/index.js and public/js/main/IndexController.js . This project is configured in a way that when we run command gulp serve it compiled all the css files in css folder and javascript files in js folder and service worker file in the root of the project with the sw.js . To register a service, first we need switch branch. git reset --hard if you have any local changes run this command git checkout task-register-sw We will work on public/js/sw/index.js inside _registerServiceWorker function. First we need to check if the service worker is supported by the broswer or not, to do so we need to check for service worker object in navigator . Navigator object contains the information about the user agent and browser. if (!navigator.serviceWorker) return; navigator.serviceWorker.register('/sw.js').then(function(reg) { console.log('Registeration successfull'); }, function(err) { console.log('Error in registeration'); }); Exploring the Dev Tools Hijacking Request Custom Response We can give a custom response to browser request using service worker, to handle the network request we will add a Event Listner on public/js/sw/index.js . self.addEventListner('fetch', function(event) { event.respondWith( new Response('Hello World') ); }) This will be the output we get for any request browser do. self.addEventListner('fetch', function(event) { event.respondWith( new Response('Hello World b Faraz /b ') ); }) What if i add the html tag inside my Hello World string. let see. It will render as a string because in the response header the Content-Type is set to be plain/text by default, so we set it to text/html . self.addEventListner('fetch', function(event) { event.respondWith( new Response('Hello World b Faraz /b ', { headers: { 'Content-Type': 'text/html' }}) ); }) Respond with gif To get to the position of code done above run: git reset --hard git checkout task-customer-response To respond with gif for the requested url: self.addEventListner('fetch', function(event) { event.respondWith( new Response( fetch('/imgs/devil.gif') ) ); }) The above code respond every request with gif but that's not the better way, now we respond only the request of img with gif response. To do so log event and check for the url and react according to that, let me show how to do that: git reset --hard git checkout gif-response self.addEventListner('fetch', function(event) { console.log(event.request.url); if (event.request.url.endsWith('.jpg')) { event.respondWith( new Response( fetch('/imgs/devil.gif') ) ); } }) Handle 404 and failed state To handle 404 and failed state we look at then response status: self.addEventListner('fetch', function(event) { event.respondWith( new Response( fetch(event.request.url).then(function(response) { if (response.status === 404) { return new Response('NOT FOUND'); } }).catch(function(err) { return new Response('ERROR'); }) ); ); }) Now we will show the devil.gif to 404 status: To do this first get on the branch git reset --hard git checkout error-handling self.addEventListner('fetch', function(event) { event.respondWith( new Response( fetch(event.request.url).then(function(response) { if (response.status === 404) { return fetch('/imgs/devil.gif') } }).catch(function(err) { return new Response('ERROR'); }) ); ); }) Caching and Serving Assets To cache the static files we have to create cache and add the files on install event of service worker. git reset --hard git checkout task-install self.addEventListner('install', function(event) { event.waitUntil( caches.open('wittr-v1').then(function(cache) { cache.addAll([ '/', '/style.css', '/main.js' ]) }) ) }) Now we cached the data in the CacheStorage, but we request the site we will still be kept waiting. Now we have to check if there is any data in cache we will show it from there otherwise show it from network. git reset --hard git checkout task-cache-response self.addEventListner('fetch', function(event) { event.respondWith( caches.match(event.request.url).then(function(response) { if (response) return response; return fetch(event.request) }) ) }) Till now we acheive to show something rather than a blank page or a dinosur but we have still to do alot, we are not getting the updated app or nor doesnt know about the update is here. So now what problems we have to acheive right now: Unobtrusive app updates Get the user on to the latest version Continously update the cache of posts Cache photos Cache avatar Unobtrusive app updates If we update our css and force reload is checked we can see the changes in browser but if we unchecked the force update and the change the css the broswer doent detch the changes and show the old one because we didnt update the service worker and another service worker is active. git reset --hard git checkout task-handling-updates To deal with this we will delete the old cache on the activate event. The easy step is: self.addEventListner('activate', function(event) { event.waitUntil( caches.delete('wittr-static-v1') ) }) The scalable way: var staticCacheName = 'wittr-static-v2'; self.addEventListner('activate', function(event) { event.waitUntil( Promise.all( caches.keys().then(function(cacheNames){ cacheNames.filter(function(cacheName){ return cacheName.startWith('wittr-') cacheName != staticCacheName; }).map(function(cacheName) { return caches.delete(cacheName) }) }) ) ) }) Trigger latest version Now we will look at how we will notify user that there is an update ready to install. First we look at the properties and method given by service worker. git reset --hard git checkout sw-register-methods git checkout task-update-notify IndexController.prototype._registerServiceWorker = function() { if (!navigator.serviceWorker) return; var indexController = this; navigator.serviceWorker.register('/sw.js').then(function(reg) { // TODO: if there's no controller, this page wasn't loaded // via a service worker, so they're looking at the latest version. // In that case, exit early if (!navigator.serviceWorker.controller) return; // TODO: if there's an updated worker already waiting, call // indexController._updateReady() if(reg.waiting) { indexController._updateReady() return; } // TODO: if there's an updated worker installing, track its // progress. If it becomes installed , call // indexController._updateReady() if (reg.installing) { indexController._trackInstalling(reg.installing); return; } // TODO: otherwise, listen for new installing workers arriving. // If one arrives, track its progress. // If it becomes installed , call // indexController._updateReady() reg.addEventListner('updatefound', function() { indexController._trackInstalling(reg.installing); }) }); }; IndexController.prototype._trackInstalling = function(worker) { var indexController = this; worker.addEventListner('statechange', function() { if (worker.state === 'installed') { indexController._updateReady() } }); } By the above code we can now sent notification to user about the update but how we will trigger the update. let see: First we see some of the methods and properties of service worker. self.skipWaiting() is a function to manually tell service worker to active the waiting service worker. form the registration object we can emit data to service worker which can be recieve in message event reg.installing.postMessage({ bar: foo }) ; self.addEventListner('message', function(event) { console.log(event.data); }); There is an another event that attached on navigator controller to check if the controller is changed navigator.serviceWorker.addEventListner('controllerchange', function() { // change happens reload the page }) Now we are going to trigger the update with the use of above information git reset --hard git checkout task-update-reload IndexController.prototype._updateReady = function(worker) { var toast = this._toastsView.show( New version available , { buttons: ['refresh', 'dismiss'] }); toast.answer.then(function(answer) { if (answer != 'refresh') return; // TODO: tell the service worker to skipWaiting worker.postMessage({ action: 'skipWaiting' }); }); }; // in sw/index.js self.addEventListner('message', function(event) { if (event.data.action === 'skipWaiting') { self.skipWaiting(); } }); // in indexController.js inside register function navigator.serviceWorker.addEventListner('controllerchange', function() { window.location.reload(); }) Update Data using the IndexedDB Introduction to IndexedDB In general, there are two different types of databases: relational and document (also known as NoSQL or object). Relational databases like SQL Server, MySQL, and Oracle store sets of data in tables. Document databases like MongoDB, CouchDB, and Redis store sets of data as individual objects. IndexedDB is a document database that exists in a sandboxed context. It contains the object stores, you can create multiple databases with whatever names you choose, but generally there is one database per app. Object store An object store is an individual bucket to store data. You can think of object stores as being similar to tables in traditional relational databases. Index An Index is a kind of object store for organizing data in another object store (called the reference object store) by an individual property of the data. The index is used to retrieve records in the object store by this property. For example, if you're storing people, you may want to fetch them later by their name, age, or favorite animal. Transaction A transaction is wrapper around an operation, or group of operations, that ensures database integrity. If one of the actions within a transaction fail, none of them are applied and the database returns to the state it was in before the transaction began. All read or write operations in IndexedDB must be part of a transaction. This allows for atomic read-modify-write operations without worrying about other threads acting on the database at the same time. Cursor A mechanism for iterating over multiple records in database. Create a db //check for support if (!('indexedDB' in window)) { console.log('This browser doesn\\'t support IndexedDB'); return; } var dbPromise = idb.open('test-db1', 1); Create a Object store //check for support if (!('indexedDB' in window)) { console.log('This browser doesn\\'t support IndexedDB'); return; } var dbPromise = idb.open('test-db2', 1, function(upgradeDb) { console.log('making a new object store'); if (!upgradeDb.objectStoreNames.contains('firstOS')) { upgradeDb.createObjectStore('firstOS'); } }); upgradeDb.createObjectStore('people', {keyPath: 'email'}); KeyPath is used to define the primary key Defining indexes objectStore.createIndex('indexName', 'property', options); //check for support if (!('indexedDB' in window)) { console.log('This browser doesn\\'t support IndexedDB'); return; } var dbPromise = idb.open('test-db4', 1, function(upgradeDb) { if (!upgradeDb.objectStoreNames.contains('people')) { var peopleOS = upgradeDb.createObjectStore('people', {keyPath: 'email'}); peopleOS.createIndex('gender', 'gender', {unique: false}); peopleOS.createIndex('username', 'username', {unique: true}); } }); git checkout task-idb-store function openDatabase() { // If the browser doesn't support service worker, // we don't care about having a database if (!navigator.serviceWorker) { return Promise.resolve(); } return idb.open('wittr', 1, function(upgradeDb) { var store = upgradeDb.createObjectStore('wittrs', { keyPath: 'id' }); store.createIndex('by-date', 'time'); }); } IndexController.prototype._onSocketMessage = function(data) { var messages = JSON.parse(data); this._dbPromise.then(function(db) { if (!db) return; var tx = db.transaction('wittrs', 'readwrite'); var store = tx.objectStore('wittrs'); messages.forEach(function(message) { store.put(message); }); }); this._postsView.addPosts(messages); }; git checkout task-show-stored IndexController.prototype._showCachedMessages = function() { var indexController = this; return this._dbPromise.then(function(db) { // if we're already showing posts, eg shift-refresh // or the very first load, there's no point fetching // posts from IDB if (!db || indexController._postsView.showingPosts()) return; var index = db.transaction('wittrs') .objectStore('wittrs').index('by-date'); return index.getAll().then(function(messages) { indexController._postsView.addPosts(messages.reverse()); }); }); };","title":"3. Intro to Service Workers (2 of 2)"},{"location":"intro-service-worker-2/#introduction-to-service-worker","text":"","title":"Introduction to Service Worker"},{"location":"intro-service-worker-2/#table-of-content","text":"Topics Overview App Introduction Installing/Running the App Registering our first Service Worker Exploring the Dev Tools Hijacking Request Caching and Serving Assets Unobtrosive App Updates Trigger latest version Update Data using the IndexedDB","title":"Table of Content"},{"location":"intro-service-worker-2/#overview","text":"Service worker is a JavaScript file that, run seperately in its own thread. Intercepts network request and store or retrive data from cache and provide push message to web client even when offline. It doesn't have DOM support and only run on HTTPS. Service worker doesn't have access to DOM, so what can we do with JavaScript? Lets discus this. Service worker is like a middle man (or middleware) between the webpage and the internet, it handle the network request. When a webpage request the server for HTML, CSS files or any API request it pass through the service worker, it is up to us how we code the service worker to deal with these request like we can send that request to server or we can look for the request in cache if exist then show from cache. It is up to us what approach is better for us to provide a good user experience.","title":"Overview"},{"location":"intro-service-worker-2/#app-introduction","text":"We have an app called Wittr , it is a real time social networking web app where user share their posts and give comments/feedback on them. This site is fully developed but not a total breakdown on low connectivity and offline mode. So we going to implement the service worker to tackle the blank screen on low connectivity and offline mode.","title":"App Introduction"},{"location":"intro-service-worker-2/#installingrunning-the-app","text":"To install the app on you local machine, you first need to install Git if you have it that's great. If you dont know about Git that's not an issue we are just using the basic of Git . Those who dont know Git, it is a version controlling system. To download or clone the project to your local machine, run command on your terminal or command-line. git clone https://github.com/farazsarwar113/wittr After cloning the project run command npm install to install all the dependencies required by the project. To run the app run gulp serve . It will run the app on http://localhost:8888 and server on http://localhost:8889 .","title":"Installing/Running the App"},{"location":"intro-service-worker-2/#registering-our-first-service-worker","text":"We need to work on only two files throughout the app public/js/sw/index.js and public/js/main/IndexController.js . This project is configured in a way that when we run command gulp serve it compiled all the css files in css folder and javascript files in js folder and service worker file in the root of the project with the sw.js . To register a service, first we need switch branch. git reset --hard if you have any local changes run this command git checkout task-register-sw We will work on public/js/sw/index.js inside _registerServiceWorker function. First we need to check if the service worker is supported by the broswer or not, to do so we need to check for service worker object in navigator . Navigator object contains the information about the user agent and browser. if (!navigator.serviceWorker) return; navigator.serviceWorker.register('/sw.js').then(function(reg) { console.log('Registeration successfull'); }, function(err) { console.log('Error in registeration'); });","title":"Registering our first Service Worker"},{"location":"intro-service-worker-2/#exploring-the-dev-tools","text":"","title":"Exploring the Dev Tools"},{"location":"intro-service-worker-2/#hijacking-request","text":"","title":"Hijacking Request"},{"location":"intro-service-worker-2/#custom-response","text":"We can give a custom response to browser request using service worker, to handle the network request we will add a Event Listner on public/js/sw/index.js . self.addEventListner('fetch', function(event) { event.respondWith( new Response('Hello World') ); }) This will be the output we get for any request browser do. self.addEventListner('fetch', function(event) { event.respondWith( new Response('Hello World b Faraz /b ') ); }) What if i add the html tag inside my Hello World string. let see. It will render as a string because in the response header the Content-Type is set to be plain/text by default, so we set it to text/html . self.addEventListner('fetch', function(event) { event.respondWith( new Response('Hello World b Faraz /b ', { headers: { 'Content-Type': 'text/html' }}) ); })","title":"Custom Response"},{"location":"intro-service-worker-2/#respond-with-gif","text":"To get to the position of code done above run: git reset --hard git checkout task-customer-response To respond with gif for the requested url: self.addEventListner('fetch', function(event) { event.respondWith( new Response( fetch('/imgs/devil.gif') ) ); }) The above code respond every request with gif but that's not the better way, now we respond only the request of img with gif response. To do so log event and check for the url and react according to that, let me show how to do that: git reset --hard git checkout gif-response self.addEventListner('fetch', function(event) { console.log(event.request.url); if (event.request.url.endsWith('.jpg')) { event.respondWith( new Response( fetch('/imgs/devil.gif') ) ); } })","title":"Respond with gif"},{"location":"intro-service-worker-2/#handle-404-and-failed-state","text":"To handle 404 and failed state we look at then response status: self.addEventListner('fetch', function(event) { event.respondWith( new Response( fetch(event.request.url).then(function(response) { if (response.status === 404) { return new Response('NOT FOUND'); } }).catch(function(err) { return new Response('ERROR'); }) ); ); }) Now we will show the devil.gif to 404 status: To do this first get on the branch git reset --hard git checkout error-handling self.addEventListner('fetch', function(event) { event.respondWith( new Response( fetch(event.request.url).then(function(response) { if (response.status === 404) { return fetch('/imgs/devil.gif') } }).catch(function(err) { return new Response('ERROR'); }) ); ); })","title":"Handle 404 and failed state"},{"location":"intro-service-worker-2/#caching-and-serving-assets","text":"To cache the static files we have to create cache and add the files on install event of service worker. git reset --hard git checkout task-install self.addEventListner('install', function(event) { event.waitUntil( caches.open('wittr-v1').then(function(cache) { cache.addAll([ '/', '/style.css', '/main.js' ]) }) ) }) Now we cached the data in the CacheStorage, but we request the site we will still be kept waiting. Now we have to check if there is any data in cache we will show it from there otherwise show it from network. git reset --hard git checkout task-cache-response self.addEventListner('fetch', function(event) { event.respondWith( caches.match(event.request.url).then(function(response) { if (response) return response; return fetch(event.request) }) ) }) Till now we acheive to show something rather than a blank page or a dinosur but we have still to do alot, we are not getting the updated app or nor doesnt know about the update is here. So now what problems we have to acheive right now: Unobtrusive app updates Get the user on to the latest version Continously update the cache of posts Cache photos Cache avatar","title":"Caching and Serving Assets"},{"location":"intro-service-worker-2/#unobtrusive-app-updates","text":"If we update our css and force reload is checked we can see the changes in browser but if we unchecked the force update and the change the css the broswer doent detch the changes and show the old one because we didnt update the service worker and another service worker is active. git reset --hard git checkout task-handling-updates To deal with this we will delete the old cache on the activate event. The easy step is: self.addEventListner('activate', function(event) { event.waitUntil( caches.delete('wittr-static-v1') ) }) The scalable way: var staticCacheName = 'wittr-static-v2'; self.addEventListner('activate', function(event) { event.waitUntil( Promise.all( caches.keys().then(function(cacheNames){ cacheNames.filter(function(cacheName){ return cacheName.startWith('wittr-') cacheName != staticCacheName; }).map(function(cacheName) { return caches.delete(cacheName) }) }) ) ) })","title":"Unobtrusive app updates"},{"location":"intro-service-worker-2/#trigger-latest-version","text":"Now we will look at how we will notify user that there is an update ready to install. First we look at the properties and method given by service worker. git reset --hard git checkout sw-register-methods git checkout task-update-notify IndexController.prototype._registerServiceWorker = function() { if (!navigator.serviceWorker) return; var indexController = this; navigator.serviceWorker.register('/sw.js').then(function(reg) { // TODO: if there's no controller, this page wasn't loaded // via a service worker, so they're looking at the latest version. // In that case, exit early if (!navigator.serviceWorker.controller) return; // TODO: if there's an updated worker already waiting, call // indexController._updateReady() if(reg.waiting) { indexController._updateReady() return; } // TODO: if there's an updated worker installing, track its // progress. If it becomes installed , call // indexController._updateReady() if (reg.installing) { indexController._trackInstalling(reg.installing); return; } // TODO: otherwise, listen for new installing workers arriving. // If one arrives, track its progress. // If it becomes installed , call // indexController._updateReady() reg.addEventListner('updatefound', function() { indexController._trackInstalling(reg.installing); }) }); }; IndexController.prototype._trackInstalling = function(worker) { var indexController = this; worker.addEventListner('statechange', function() { if (worker.state === 'installed') { indexController._updateReady() } }); } By the above code we can now sent notification to user about the update but how we will trigger the update. let see: First we see some of the methods and properties of service worker. self.skipWaiting() is a function to manually tell service worker to active the waiting service worker. form the registration object we can emit data to service worker which can be recieve in message event reg.installing.postMessage({ bar: foo }) ; self.addEventListner('message', function(event) { console.log(event.data); }); There is an another event that attached on navigator controller to check if the controller is changed navigator.serviceWorker.addEventListner('controllerchange', function() { // change happens reload the page }) Now we are going to trigger the update with the use of above information git reset --hard git checkout task-update-reload IndexController.prototype._updateReady = function(worker) { var toast = this._toastsView.show( New version available , { buttons: ['refresh', 'dismiss'] }); toast.answer.then(function(answer) { if (answer != 'refresh') return; // TODO: tell the service worker to skipWaiting worker.postMessage({ action: 'skipWaiting' }); }); }; // in sw/index.js self.addEventListner('message', function(event) { if (event.data.action === 'skipWaiting') { self.skipWaiting(); } }); // in indexController.js inside register function navigator.serviceWorker.addEventListner('controllerchange', function() { window.location.reload(); })","title":"Trigger latest version"},{"location":"intro-service-worker-2/#update-data-using-the-indexeddb","text":"","title":"Update Data using the IndexedDB"},{"location":"intro-service-worker-2/#introduction-to-indexeddb","text":"In general, there are two different types of databases: relational and document (also known as NoSQL or object). Relational databases like SQL Server, MySQL, and Oracle store sets of data in tables. Document databases like MongoDB, CouchDB, and Redis store sets of data as individual objects. IndexedDB is a document database that exists in a sandboxed context. It contains the object stores, you can create multiple databases with whatever names you choose, but generally there is one database per app.","title":"Introduction to IndexedDB"},{"location":"intro-service-worker-2/#object-store","text":"An object store is an individual bucket to store data. You can think of object stores as being similar to tables in traditional relational databases.","title":"Object store"},{"location":"intro-service-worker-2/#index","text":"An Index is a kind of object store for organizing data in another object store (called the reference object store) by an individual property of the data. The index is used to retrieve records in the object store by this property. For example, if you're storing people, you may want to fetch them later by their name, age, or favorite animal.","title":"Index"},{"location":"intro-service-worker-2/#transaction","text":"A transaction is wrapper around an operation, or group of operations, that ensures database integrity. If one of the actions within a transaction fail, none of them are applied and the database returns to the state it was in before the transaction began. All read or write operations in IndexedDB must be part of a transaction. This allows for atomic read-modify-write operations without worrying about other threads acting on the database at the same time.","title":"Transaction"},{"location":"intro-service-worker-2/#cursor","text":"A mechanism for iterating over multiple records in database.","title":"Cursor"},{"location":"intro-service-worker-2/#create-a-db","text":"//check for support if (!('indexedDB' in window)) { console.log('This browser doesn\\'t support IndexedDB'); return; } var dbPromise = idb.open('test-db1', 1);","title":"Create a db"},{"location":"intro-service-worker-2/#create-a-object-store","text":"//check for support if (!('indexedDB' in window)) { console.log('This browser doesn\\'t support IndexedDB'); return; } var dbPromise = idb.open('test-db2', 1, function(upgradeDb) { console.log('making a new object store'); if (!upgradeDb.objectStoreNames.contains('firstOS')) { upgradeDb.createObjectStore('firstOS'); } }); upgradeDb.createObjectStore('people', {keyPath: 'email'}); KeyPath is used to define the primary key","title":"Create a Object store"},{"location":"intro-service-worker-2/#defining-indexes","text":"objectStore.createIndex('indexName', 'property', options); //check for support if (!('indexedDB' in window)) { console.log('This browser doesn\\'t support IndexedDB'); return; } var dbPromise = idb.open('test-db4', 1, function(upgradeDb) { if (!upgradeDb.objectStoreNames.contains('people')) { var peopleOS = upgradeDb.createObjectStore('people', {keyPath: 'email'}); peopleOS.createIndex('gender', 'gender', {unique: false}); peopleOS.createIndex('username', 'username', {unique: true}); } }); git checkout task-idb-store function openDatabase() { // If the browser doesn't support service worker, // we don't care about having a database if (!navigator.serviceWorker) { return Promise.resolve(); } return idb.open('wittr', 1, function(upgradeDb) { var store = upgradeDb.createObjectStore('wittrs', { keyPath: 'id' }); store.createIndex('by-date', 'time'); }); } IndexController.prototype._onSocketMessage = function(data) { var messages = JSON.parse(data); this._dbPromise.then(function(db) { if (!db) return; var tx = db.transaction('wittrs', 'readwrite'); var store = tx.objectStore('wittrs'); messages.forEach(function(message) { store.put(message); }); }); this._postsView.addPosts(messages); }; git checkout task-show-stored IndexController.prototype._showCachedMessages = function() { var indexController = this; return this._dbPromise.then(function(db) { // if we're already showing posts, eg shift-refresh // or the very first load, there's no point fetching // posts from IDB if (!db || indexController._postsView.showingPosts()) return; var index = db.transaction('wittrs') .objectStore('wittrs').index('by-date'); return index.getAll().then(function(messages) { indexController._postsView.addPosts(messages.reverse()); }); }); };","title":"Defining indexes"},{"location":"intro-service-worker/","text":"Introduction to Service Worker Table of Content Topics Real world problems Introduction to Service Worker Benefits of Offline First Registering a Service Worker Lifecycle of Service Worker Real world example Introduction to Service Worker Service worker is a JavaScript file that, run seperately in its own thread. Intercepts network request and store or retrive data from cache and provide push message to web client even when offline. It doesn't have DOM support and only run on HTTPS. Service worker doesn't have access to DOM, so what can we do with JavaScript? Lets discus this. Service worker is like a middle man (or middleware) between the webpage and the internet, it handle the network request. When a webpage request the server for HTML, CSS files or any API request it pass through the service worker, it is up to us how we code the service worker to deal with these request like we can send that request to server or we can look for the request in cache if exist then show from cache. It is up to us what approach is better for us to provide a good user experience. Benefits of Offline First Before service worker, AppCache was used by the developer to cache data. In AppCache first network request was made by the site to server and then cache the request when it is completed and whenever the request was failed it was retrive from AppCache . The drawback of this is, user kept waiting till the network request made or failed which is a bad exprience for the user, so that why AppCache has been depriciated and Service Worker was introduced on 08 May, 2014 . Below is the image show the working of AppCache : Referenced from Udacity Course As Service Worker was introduced, a new approach come into play to develop a web app Offline First i.e a request to a server is pass through service worker, it will look for data in cache and show the content of the web page that already cache meanwhile gets the respone from the server and show the rest of the content by this approach user wouldn't wait for page to completely load and shouldn't see the white screen all the time. Below the image describe the flow of service worker. Referenced from Udacity Course Registering a Service Worker To register a service worker, first we need to check if the service worker is supported by the broswer or not, to do so we need to check for service worker object in navigator . Navigator object contains the information about the user agent and browser. if (navigator.serviceWorker) { navigator.serviceWorker.register('/sw.js').then(function(reg) { console.log('Yay!!'); }, function(err) { console.log('Boo!!'); }); } where sw.js is the service worker file located at the root level of project (in my case) it could be of any name and located anywhere inside the project but it is good to have it on root level. Lifecycle of Service Worker Service worker handle requests to the server. It has a few steps, and to show that I\u2019ll show your a nice picture from MDN : Parsed Event When we first attempt to register a Service Worker, the user agent parses the script and obtains the entry point. If parsing is successful (and some other requirements, e.g. HTTPS, are met), we will have access to the Service Worker registration object. This contains information about the state of the Service Worker as well as it\u2019s scope. if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js') .then(function(registration) { console.log( Service Worker Registered , registration); }) .catch(function(err) { console.log( Service Worker Failed to Register , err); }) } Install Event Once the Service Worker script has been parsed, the user agent attempts to install it and it moves to the installing state. In the Service Worker registration object, we can check for this state in the installing child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.installing) { // Service Worker is Installing } }); During the installing state, the install event in the Service Worker script is carried out. The \u201cinstall\u201d event is the first event a service worker gets, and it only happens once. A promise passed to event.waitUntil() signals the duration and success or failure of your install. A service worker won't receive events like fetch and push until it successfully finishes installing and becomes \"active\". By default, a page's fetches won't go through a service worker unless the page request itself went through a service worker. So you'll need to refresh the page to see the effects of the service worker. An example image shown by Jake Archibald in his blog : To listen the install event of a service worker, we need to add the following code in our sw.js file: self.addEventListener('install', function(event) { event.waitUntil( // Open cache storage and do something ); }); Installed / Waiting If the installation is successful, the Service Worker moves to the installed (also called waiting) state. In this state it is a valid, but not yet active, worker. It is not yet in control of the document, but rather is waiting to take control from the current worker. In the Service Worker registration object, we can check for this state in the waiting child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.waiting) { // Service Worker is Waiting } }); This can be a good time to notify the app user that they can update to a new version, or automatically update for them. Activate Event After the installation of service worker, if there any existing service worker controlling the client, then this worker goes to a waiting state. The activate event fires once the old service worker is gone, and your new service worker is able to control clients. This is the ideal time to do stuff that you couldn't do while the old worker was still in use, such as migrating databases and clearing caches. The waiting phase means you're only running one version of your site at once, but if you don't need that feature, you can make your new service worker activate sooner by calling \u201cself.skipWaiting()\u201d. An example image shown by Jake Archibald in his blog : To listen the activate event of a service worker, we need to add the following code in our sw.js file: self.addEventListener('activate', function(event) { event.waitUntil( // Delete cache ); }); Activated If activation is successful, the Service Worker moves to the active state. In this state, it is an active worker in full control of the document. In the Service Worker registration object, we can check for this state in the active child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.active) { // Service Worker is Active } }); When a Service Worker is active, it can now handle the functional events - fetch, and message. self.addEventListener('fetch', function(event) { // Do stuff with fetch events }); self.addEventListener('message', function(event) { // Do stuff with postMessages received from document }); Redundant A Service Worker can become redundant for one of the following reasons - If the installing event failed If the activating event failed If a new Service Worker replaces it as the active service worker CacheStorage The Cache API is a system for storing and retrieving network requests and corresponding responses. The Cache API was created to enable Service Workers to cache network requests so that they can provide appropriate responses even while offline. However, the API can also be used as a general storage mechanism. What can be stored? The caches only store pairs of \u201cRequest\u201d and \u201cResponse\u201d objects, representing HTTP requests and responses. However, the requests and responses can contain any kind of data that can be transferred over HTTP. The API is exposed via the global \u201ccaches\u201d property, so you can test for the presence of the API with a simple feature detection: if('caches' in window) { // HAS SUPPORT!! } The API can be accessed from a window, iframe, worker, or service worker Methods of CacheStorage Methods Description open(cacheName) Returns a Promise that resolves to the Cache object matching the cacheName (a new cache is created if it doesn\u2019t already exist). match() Checks if a given Request is a key in any of the Cache objects that the CacheStorage tracks, and returns a Promise that resolves to that match. has(cacheName) Returns a Promise that resolves to \u201cTRUE\u201d if a Cache object matching the cacheName exits. keys() Returns a Promise that will resolve an array containing strings corresponding to all of the named Cache objects tracked by the CacheStorage. Use this method to iterate over a list of all the Cache object. delete(cacheName) Finds the Cache object matching the cacheName if found, delete the Cache object and returns a Promise that resolves to \u201cTRUE\u201d. If no Cache object is found, it returns \u201cFALSE\u201d. Creating or opening a cache // \u201ccaches\u201d is a global read-only variable, which is the instance of CacheStorage. caches.open('my-cache').then((cache) = { // do something with cache\u2026 }); Note: Give your cache names a unique prefix so that it don\u2019t override the other domain cache For ex: \u2018mysite-static-v1\u2019 Adding to cache caches.open('test-cache').then(function(cache) { cache.addAll(['/', '/images/logo.png']) .then(function() { // Cached! }); }); caches.open('test-cache').then(function(cache) { cache.add('/images/logo.png') .then(function() { // Cached! }); }); The addAll method accepts an array of URLs that should be cached, to add single URL, use the add method put() put() is similar to add() but in, put() we can add response object. fetch('/page/1').then(function(response) { return caches.open('test-cache') .then(function(cache) { return cache.put('/page/1', response); }); }); Retrieving Cache caches.open('test-cache').then(function(cache) { cache.keys().then(function(cachedRequests) { console.log(cachedRequests); // [Request, Request] }); }); caches.open('test-cache').then(function(cache) { cache.match('/page/1') .then(function(matchedResponse) { console.log(matchedResponse); }); }); /* Request { bodyUsed: false credentials: omit headers: Headers integrity: method: GET mode: no-cors redirect: follow referrer: url: https://staging.pitchworthy.co/images/logo.png }*/ /*Response { body: (...), bodyUsed: false, headers: Headers, ok: true, status: 200, statusText: OK , type: basic , url: https://staging.pitchworthy.co/users/me } */ caches.keys To get the names of existing caches, use \u201ccaches.keys\u201d caches.keys().then(function(cacheKeys) { console.log(cacheKeys); // ex: [ test-cache ] }); Deleting a Cache caches.delete('test-cache').then(function() { console.log('Cache successfully deleted!'); }); Delete an old cache and add new one You often need to delete an old cache and add new one. // Assuming `CACHE_NAME` is the newest name. Time to clean up the old! var CACHE_NAME = 'version-8'; caches.keys().then(function(cacheNames) { return Promise.all( cacheNames.map(function(cacheName) { if(cacheName != CACHE_NAME) { return caches.delete(cacheName); } }) ); });","title":"2. Intro to Service Workers (1 of 2)"},{"location":"intro-service-worker/#introduction-to-service-worker","text":"","title":"Introduction to Service Worker"},{"location":"intro-service-worker/#table-of-content","text":"Topics Real world problems Introduction to Service Worker Benefits of Offline First Registering a Service Worker Lifecycle of Service Worker Real world example","title":"Table of Content"},{"location":"intro-service-worker/#introduction-to-service-worker_1","text":"Service worker is a JavaScript file that, run seperately in its own thread. Intercepts network request and store or retrive data from cache and provide push message to web client even when offline. It doesn't have DOM support and only run on HTTPS. Service worker doesn't have access to DOM, so what can we do with JavaScript? Lets discus this. Service worker is like a middle man (or middleware) between the webpage and the internet, it handle the network request. When a webpage request the server for HTML, CSS files or any API request it pass through the service worker, it is up to us how we code the service worker to deal with these request like we can send that request to server or we can look for the request in cache if exist then show from cache. It is up to us what approach is better for us to provide a good user experience.","title":"Introduction to Service Worker"},{"location":"intro-service-worker/#benefits-of-offline-first","text":"Before service worker, AppCache was used by the developer to cache data. In AppCache first network request was made by the site to server and then cache the request when it is completed and whenever the request was failed it was retrive from AppCache . The drawback of this is, user kept waiting till the network request made or failed which is a bad exprience for the user, so that why AppCache has been depriciated and Service Worker was introduced on 08 May, 2014 . Below is the image show the working of AppCache : Referenced from Udacity Course As Service Worker was introduced, a new approach come into play to develop a web app Offline First i.e a request to a server is pass through service worker, it will look for data in cache and show the content of the web page that already cache meanwhile gets the respone from the server and show the rest of the content by this approach user wouldn't wait for page to completely load and shouldn't see the white screen all the time. Below the image describe the flow of service worker. Referenced from Udacity Course","title":"Benefits of Offline First"},{"location":"intro-service-worker/#registering-a-service-worker","text":"To register a service worker, first we need to check if the service worker is supported by the broswer or not, to do so we need to check for service worker object in navigator . Navigator object contains the information about the user agent and browser. if (navigator.serviceWorker) { navigator.serviceWorker.register('/sw.js').then(function(reg) { console.log('Yay!!'); }, function(err) { console.log('Boo!!'); }); } where sw.js is the service worker file located at the root level of project (in my case) it could be of any name and located anywhere inside the project but it is good to have it on root level.","title":"Registering a Service Worker"},{"location":"intro-service-worker/#lifecycle-of-service-worker","text":"Service worker handle requests to the server. It has a few steps, and to show that I\u2019ll show your a nice picture from MDN :","title":"Lifecycle of Service Worker"},{"location":"intro-service-worker/#parsed-event","text":"When we first attempt to register a Service Worker, the user agent parses the script and obtains the entry point. If parsing is successful (and some other requirements, e.g. HTTPS, are met), we will have access to the Service Worker registration object. This contains information about the state of the Service Worker as well as it\u2019s scope. if ('serviceWorker' in navigator) { navigator.serviceWorker.register('./sw.js') .then(function(registration) { console.log( Service Worker Registered , registration); }) .catch(function(err) { console.log( Service Worker Failed to Register , err); }) }","title":"Parsed Event"},{"location":"intro-service-worker/#install-event","text":"Once the Service Worker script has been parsed, the user agent attempts to install it and it moves to the installing state. In the Service Worker registration object, we can check for this state in the installing child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.installing) { // Service Worker is Installing } }); During the installing state, the install event in the Service Worker script is carried out. The \u201cinstall\u201d event is the first event a service worker gets, and it only happens once. A promise passed to event.waitUntil() signals the duration and success or failure of your install. A service worker won't receive events like fetch and push until it successfully finishes installing and becomes \"active\". By default, a page's fetches won't go through a service worker unless the page request itself went through a service worker. So you'll need to refresh the page to see the effects of the service worker. An example image shown by Jake Archibald in his blog : To listen the install event of a service worker, we need to add the following code in our sw.js file: self.addEventListener('install', function(event) { event.waitUntil( // Open cache storage and do something ); });","title":"Install Event"},{"location":"intro-service-worker/#installed-waiting","text":"If the installation is successful, the Service Worker moves to the installed (also called waiting) state. In this state it is a valid, but not yet active, worker. It is not yet in control of the document, but rather is waiting to take control from the current worker. In the Service Worker registration object, we can check for this state in the waiting child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.waiting) { // Service Worker is Waiting } }); This can be a good time to notify the app user that they can update to a new version, or automatically update for them.","title":"Installed / Waiting"},{"location":"intro-service-worker/#activate-event","text":"After the installation of service worker, if there any existing service worker controlling the client, then this worker goes to a waiting state. The activate event fires once the old service worker is gone, and your new service worker is able to control clients. This is the ideal time to do stuff that you couldn't do while the old worker was still in use, such as migrating databases and clearing caches. The waiting phase means you're only running one version of your site at once, but if you don't need that feature, you can make your new service worker activate sooner by calling \u201cself.skipWaiting()\u201d. An example image shown by Jake Archibald in his blog : To listen the activate event of a service worker, we need to add the following code in our sw.js file: self.addEventListener('activate', function(event) { event.waitUntil( // Delete cache ); });","title":"Activate Event"},{"location":"intro-service-worker/#activated","text":"If activation is successful, the Service Worker moves to the active state. In this state, it is an active worker in full control of the document. In the Service Worker registration object, we can check for this state in the active child object. navigator.serviceWorker.register('./sw.js').then(function(registration) { if (registration.active) { // Service Worker is Active } }); When a Service Worker is active, it can now handle the functional events - fetch, and message. self.addEventListener('fetch', function(event) { // Do stuff with fetch events }); self.addEventListener('message', function(event) { // Do stuff with postMessages received from document });","title":"Activated"},{"location":"intro-service-worker/#redundant","text":"A Service Worker can become redundant for one of the following reasons - If the installing event failed If the activating event failed If a new Service Worker replaces it as the active service worker","title":"Redundant"},{"location":"intro-service-worker/#cachestorage","text":"The Cache API is a system for storing and retrieving network requests and corresponding responses. The Cache API was created to enable Service Workers to cache network requests so that they can provide appropriate responses even while offline. However, the API can also be used as a general storage mechanism.","title":"CacheStorage"},{"location":"intro-service-worker/#what-can-be-stored","text":"The caches only store pairs of \u201cRequest\u201d and \u201cResponse\u201d objects, representing HTTP requests and responses. However, the requests and responses can contain any kind of data that can be transferred over HTTP. The API is exposed via the global \u201ccaches\u201d property, so you can test for the presence of the API with a simple feature detection: if('caches' in window) { // HAS SUPPORT!! } The API can be accessed from a window, iframe, worker, or service worker","title":"What can be stored?"},{"location":"intro-service-worker/#methods-of-cachestorage","text":"Methods Description open(cacheName) Returns a Promise that resolves to the Cache object matching the cacheName (a new cache is created if it doesn\u2019t already exist). match() Checks if a given Request is a key in any of the Cache objects that the CacheStorage tracks, and returns a Promise that resolves to that match. has(cacheName) Returns a Promise that resolves to \u201cTRUE\u201d if a Cache object matching the cacheName exits. keys() Returns a Promise that will resolve an array containing strings corresponding to all of the named Cache objects tracked by the CacheStorage. Use this method to iterate over a list of all the Cache object. delete(cacheName) Finds the Cache object matching the cacheName if found, delete the Cache object and returns a Promise that resolves to \u201cTRUE\u201d. If no Cache object is found, it returns \u201cFALSE\u201d.","title":"Methods of CacheStorage"},{"location":"intro-service-worker/#creating-or-opening-a-cache","text":"// \u201ccaches\u201d is a global read-only variable, which is the instance of CacheStorage. caches.open('my-cache').then((cache) = { // do something with cache\u2026 }); Note: Give your cache names a unique prefix so that it don\u2019t override the other domain cache For ex: \u2018mysite-static-v1\u2019","title":"Creating or opening a cache"},{"location":"intro-service-worker/#adding-to-cache","text":"caches.open('test-cache').then(function(cache) { cache.addAll(['/', '/images/logo.png']) .then(function() { // Cached! }); }); caches.open('test-cache').then(function(cache) { cache.add('/images/logo.png') .then(function() { // Cached! }); }); The addAll method accepts an array of URLs that should be cached, to add single URL, use the add method","title":"Adding to cache"},{"location":"intro-service-worker/#put","text":"put() is similar to add() but in, put() we can add response object. fetch('/page/1').then(function(response) { return caches.open('test-cache') .then(function(cache) { return cache.put('/page/1', response); }); });","title":"put()"},{"location":"intro-service-worker/#retrieving-cache","text":"caches.open('test-cache').then(function(cache) { cache.keys().then(function(cachedRequests) { console.log(cachedRequests); // [Request, Request] }); }); caches.open('test-cache').then(function(cache) { cache.match('/page/1') .then(function(matchedResponse) { console.log(matchedResponse); }); }); /* Request { bodyUsed: false credentials: omit headers: Headers integrity: method: GET mode: no-cors redirect: follow referrer: url: https://staging.pitchworthy.co/images/logo.png }*/ /*Response { body: (...), bodyUsed: false, headers: Headers, ok: true, status: 200, statusText: OK , type: basic , url: https://staging.pitchworthy.co/users/me } */","title":"Retrieving Cache"},{"location":"intro-service-worker/#cacheskeys","text":"To get the names of existing caches, use \u201ccaches.keys\u201d caches.keys().then(function(cacheKeys) { console.log(cacheKeys); // ex: [ test-cache ] });","title":"caches.keys"},{"location":"intro-service-worker/#deleting-a-cache","text":"caches.delete('test-cache').then(function() { console.log('Cache successfully deleted!'); });","title":"Deleting a Cache"},{"location":"intro-service-worker/#delete-an-old-cache-and-add-new-one","text":"You often need to delete an old cache and add new one. // Assuming `CACHE_NAME` is the newest name. Time to clean up the old! var CACHE_NAME = 'version-8'; caches.keys().then(function(cacheNames) { return Promise.all( cacheNames.map(function(cacheName) { if(cacheName != CACHE_NAME) { return caches.delete(cacheName); } }) ); });","title":"Delete an old cache and add new one"},{"location":"js-async-await/","text":"Event loops and the asynchronous programming in Javascript This STS is based on the importance of Asynchronous programming in Javascript and how Javascript actually works, how it executes callbacks and handles asynchronous code. It will also cover how to use Callbacks, Promises and Async Await effectively in your code. This session will also cover little bit about the concept of Generators in javaScript. Links Slide Introduction The session is divided into three sections. The first section will cover how event loops and call stack work in JavaScript. The Second section will cover how to write non-blocking and asynchronous code in JavaScript and how to use Promises, call backs and Async-Await effectively and then the last section will cover the concept of Generators in Javascript. WHY Event Loops and Call Stack ? Call stacks and event loops are very important and it helps you understand how Javascript actually runs on browser and node. It also helps you in understanding how callbacks are actually handled in JavaScript. WHY Aysnc Await ? ES 2017 introduced Asynchronous functions. Async functions are essentially a cleaner way to work with asynchronous code in JavaScript. Here are some important points to remember: Async/await is a new way to write asynchronous code. Previous options for asynchronous code are callbacks and promises. Async/await is actually built on top of promises. It cannot be used with plain callbacks or node callbacks. Async/await is, like promises, non blocking. Async/await makes asynchronous code look and behave a little more like synchronous code. This is where all its power lies. WHY Generators ? Generators are functions that you can use to control the iterator. They can be suspended and later resumed at any time. So if you wanna do something in your function which involves stopping it and perform other operations and then resume that function again, you should learn how to use Generators. STS Date 04 - AUG - 2017 STS Duration 30-45 Mins STS Slides Google Docs Slides STS Snacks are on the house Donuts !","title":"1. JS Async Await"},{"location":"js-async-await/#event-loops-and-the-asynchronous-programming-in-javascript","text":"This STS is based on the importance of Asynchronous programming in Javascript and how Javascript actually works, how it executes callbacks and handles asynchronous code. It will also cover how to use Callbacks, Promises and Async Await effectively in your code. This session will also cover little bit about the concept of Generators in javaScript.","title":"Event loops and the asynchronous programming in Javascript"},{"location":"js-async-await/#links","text":"Slide","title":"Links"},{"location":"js-async-await/#introduction","text":"The session is divided into three sections. The first section will cover how event loops and call stack work in JavaScript. The Second section will cover how to write non-blocking and asynchronous code in JavaScript and how to use Promises, call backs and Async-Await effectively and then the last section will cover the concept of Generators in Javascript.","title":"Introduction"},{"location":"js-async-await/#why-event-loops-and-call-stack","text":"Call stacks and event loops are very important and it helps you understand how Javascript actually runs on browser and node. It also helps you in understanding how callbacks are actually handled in JavaScript.","title":"WHY Event Loops and Call Stack ?"},{"location":"js-async-await/#why-aysnc-await","text":"ES 2017 introduced Asynchronous functions. Async functions are essentially a cleaner way to work with asynchronous code in JavaScript. Here are some important points to remember: Async/await is a new way to write asynchronous code. Previous options for asynchronous code are callbacks and promises. Async/await is actually built on top of promises. It cannot be used with plain callbacks or node callbacks. Async/await is, like promises, non blocking. Async/await makes asynchronous code look and behave a little more like synchronous code. This is where all its power lies.","title":"WHY Aysnc Await ?"},{"location":"js-async-await/#why-generators","text":"Generators are functions that you can use to control the iterator. They can be suspended and later resumed at any time. So if you wanna do something in your function which involves stopping it and perform other operations and then resume that function again, you should learn how to use Generators.","title":"WHY Generators ?"},{"location":"js-async-await/#sts-date","text":"04 - AUG - 2017","title":"STS Date"},{"location":"js-async-await/#sts-duration","text":"30-45 Mins","title":"STS Duration"},{"location":"js-async-await/#sts-slides","text":"Google Docs Slides","title":"STS Slides"},{"location":"js-async-await/#sts-snacks-are-on-the-house","text":"Donuts !","title":"STS Snacks are on the house"},{"location":"sts-intro/","text":"STS Intro This STS is based on, The importance of and general announcement of the Sudofy Tech Session! Links Slide Introduction Sudofy Tech Session is an awesome way of sharing your experience at sudofy! These session helps create technology awareness between the developers of sudofy. These session will be conducted every alternate week on Monday. A session can only be 30 to 45 mins long. WHY STS ? The greatest enemy of learning is knowing. John Maxwell STS is going to help us involve in healthy discussion on development and daily process. Each Session will comply to these common goals How to value customer satisfaction How to increase efficiency at work Deliver Quality code Ways to improve UI/UX Future Technology that can beneficial Increase governance and security of apps HOW STS ? The next question is how are we going to conduct these session at sudofy. As mentioned above we are going to do this every alternate week on Monday. Further lets discuss the flow of the session STS Days Every Alternate Monday STS Duration 30-45 Mins STS Timeline The Timeline for this session will updated frequently and all future and past STS will be listed over here STS contribution Before giving any STS you have to submit a PR with your docs and slides. The PR must be submitted 3 days before the STS STS Docs Each STS will include its own Doc page written in MkdDos STS Slides Each STS Will include its own slides created on Google Docs Slides STS Snacks are on the house Each STS session will end with refreshments and snacks WHAT STS ? What will be included in a STS? STS Will be a short byte sized session on any Technology that the developer want to share with his follow developers. STS Topics New Technology QA/Testing Deployment Techniques Framework upgrade Dev Tools FAQS Where to host my Slides Kindly use Google Docs Slides How to write the Docs Kindly use MkdDos When To Submit a PR A PR for STS Should be submitted 3 days before the STS In case of not conducting (as a speaker) the STS For any case if you are not able to conduct the STS kindly inform 4 days before the STS Do I have to attend a STS Every Developer at sudofy must attend every STS","title":"0. Introduction"},{"location":"sts-intro/#sts-intro","text":"This STS is based on, The importance of and general announcement of the Sudofy Tech Session!","title":"STS Intro"},{"location":"sts-intro/#links","text":"Slide","title":"Links"},{"location":"sts-intro/#introduction","text":"Sudofy Tech Session is an awesome way of sharing your experience at sudofy! These session helps create technology awareness between the developers of sudofy. These session will be conducted every alternate week on Monday. A session can only be 30 to 45 mins long.","title":"Introduction"},{"location":"sts-intro/#why-sts","text":"The greatest enemy of learning is knowing. John Maxwell STS is going to help us involve in healthy discussion on development and daily process. Each Session will comply to these common goals How to value customer satisfaction How to increase efficiency at work Deliver Quality code Ways to improve UI/UX Future Technology that can beneficial Increase governance and security of apps","title":"WHY STS ?"},{"location":"sts-intro/#how-sts","text":"The next question is how are we going to conduct these session at sudofy. As mentioned above we are going to do this every alternate week on Monday. Further lets discuss the flow of the session","title":"HOW STS ?"},{"location":"sts-intro/#sts-days","text":"Every Alternate Monday","title":"STS Days"},{"location":"sts-intro/#sts-duration","text":"30-45 Mins","title":"STS Duration"},{"location":"sts-intro/#sts-timeline","text":"The Timeline for this session will updated frequently and all future and past STS will be listed over here","title":"STS Timeline"},{"location":"sts-intro/#sts-contribution","text":"Before giving any STS you have to submit a PR with your docs and slides. The PR must be submitted 3 days before the STS","title":"STS contribution"},{"location":"sts-intro/#sts-docs","text":"Each STS will include its own Doc page written in MkdDos","title":"STS Docs"},{"location":"sts-intro/#sts-slides","text":"Each STS Will include its own slides created on Google Docs Slides","title":"STS Slides"},{"location":"sts-intro/#sts-snacks-are-on-the-house","text":"Each STS session will end with refreshments and snacks","title":"STS Snacks are on the house"},{"location":"sts-intro/#what-sts","text":"What will be included in a STS? STS Will be a short byte sized session on any Technology that the developer want to share with his follow developers.","title":"WHAT STS ?"},{"location":"sts-intro/#sts-topics","text":"New Technology QA/Testing Deployment Techniques Framework upgrade Dev Tools","title":"STS Topics"},{"location":"sts-intro/#faqs","text":"Where to host my Slides Kindly use Google Docs Slides How to write the Docs Kindly use MkdDos When To Submit a PR A PR for STS Should be submitted 3 days before the STS In case of not conducting (as a speaker) the STS For any case if you are not able to conduct the STS kindly inform 4 days before the STS Do I have to attend a STS Every Developer at sudofy must attend every STS","title":"FAQS"}]}